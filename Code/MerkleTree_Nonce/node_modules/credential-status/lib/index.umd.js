(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('did-jwt')) :
  typeof define === 'function' && define.amd ? define(['exports', 'did-jwt'], factory) :
  (global = global || self, factory(global.credentialStatus = {}, global.didJwt));
})(this, (function (exports, didJwt) {
  /**
   * [draft] An implementation of a StatusMethod that can aggregate multiple other methods.
   * It calls the appropriate method based on the `status.type` specified in the credential.
   */

  class Status {
    /**
     * All the expected StatusMethods should be registered during construction.
     * Example:
     * ```typescript
     * const status = new Status({
     *   ...new EthrStatusRegistry(config).asStatusMethod,                       //using convenience method
     *   "CredentialStatusList2017": new CredentialStatusList2017().checkStatus, //referencing a checkStatus
     * implementation
     *   "CustomStatusChecker": customStatusCheckerMethod                        //directly referencing an independent
     * method
     * })
     * ```
     */
    constructor(registry = {}) {
      this.registry = void 0;
      this.registry = registry;
    }

    checkStatus(credential, didDoc) {
      try {
        const _this = this;

        // TODO: validate the credential to be VerifiableCredential or VerifiablePresentation
        const decoded = didJwt.decodeJWT(credential);
        const statusEntry = decoded.payload.credentialStatus;

        if (typeof statusEntry === 'undefined') {
          return Promise.resolve({});
        }

        const method = _this.registry[statusEntry.type];

        if (typeof method !== 'undefined' && method != null) {
          return Promise.resolve(method(credential, didDoc));
        } else {
          return Promise.resolve({
            // Once the credential status mechanisms in W3C get more stable, perhaps this can become a `reject`
            error: `Credential status method ${statusEntry.type} unknown. Validity can not be determined.`
          });
        }

        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    }

  }

  exports.Status = Status;

}));
//# sourceMappingURL=index.umd.js.map
